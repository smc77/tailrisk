{
  "hash": "67763bf24919e125690446e4ab6be0ee",
  "result": {
    "engine": "jupyter",
    "markdown": "# Simulation Framework\n# Simulation Framework\n\nWe simulate synthetic return paths to test drawdown-mitigation rules under controlled statistical environments. This enables us to:\n\n- Hold volatility constant while varying drift or autocorrelation.\n- Quantify how stop-loss rules perform relative to buy-and-hold when return persistence changes.\n- Observe how MDD, average drawdown, volatility, and Sharpe ratio respond to rule changes.\n\n## AR(1) process with trailing stop-loss\n\nThe base process for log-returns is:\n\n$$\nr_t = \\mu + \\rho (r_{t-1} - \\mu) + \\sigma \\varepsilon_t, \\quad \\varepsilon_t \\sim \\mathcal{N}(0,1)\n$$\n\n- $\\mu$: daily drift  \n- $\\rho$: lag-1 autocorrelation coefficient  \n- $\\sigma$: daily volatility  \n- We parameterize $\\mu$ and $\\sigma$ in **annualized** terms for interpretability.\n\nThe stop-loss rule is:\n\n- **Trigger**: 5% trailing peak-to-trough decline in portfolio value.\n- **Exit**: Go to cash immediately upon breach.\n- **Re-entry**: Only when price exceeds the prior peak (“stop-out peak”), ensuring no premature re-risking.\n\n---\n\n## Implementation\n\n::: {#cell-simulate-ar1 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef simulate_ar1_paths(n_paths=100, n_days=252*5, mu_ann=0.0, sigma_ann=0.05, rho=0.0, seed=42):\n    np.random.seed(seed)\n    mu = mu_ann / 252\n    sigma = sigma_ann / np.sqrt(252)\n    rets = np.zeros((n_days, n_paths))\n    shocks = np.random.randn(n_days, n_paths)\n    for t in range(1, n_days):\n        rets[t] = mu + rho * (rets[t-1] - mu) + sigma * shocks[t]\n    return rets\n\ndef apply_trailing_stop(returns, stop=0.05):\n    \"\"\"returns: 1D array of daily returns\"\"\"\n    wealth = np.cumprod(1 + returns)\n    peak = np.maximum.accumulate(wealth)\n    in_market = np.ones(len(wealth), dtype=bool)\n    cash = 0.0\n    stop_peak = peak[0]\n    for t in range(1, len(wealth)):\n        if in_market[t-1]:\n            # Check stop breach\n            if (wealth[t] / peak[t] - 1) <= -stop:\n                in_market[t] = False\n                cash = wealth[t]\n                stop_peak = peak[t]\n            else:\n                in_market[t] = True\n        else:\n            # Stay in cash until break above stop_peak\n            if wealth[t] >= stop_peak:\n                in_market[t] = True\n                cash = 0.0\n            else:\n                in_market[t] = False\n    strat_wealth = np.ones(len(wealth))\n    strat_wealth[0] = 1.0\n    in_cash = False\n    for t in range(1, len(wealth)):\n        if in_market[t]:\n            strat_wealth[t] = strat_wealth[t-1] * (1 + returns[t])\n        else:\n            strat_wealth[t] = strat_wealth[t-1]\n    return strat_wealth\n\ndef metrics(wealth):\n    rets = pd.Series(wealth).pct_change().dropna()\n    vol = rets.std() * np.sqrt(252)\n    cagr = (wealth[-1]/wealth[0])**(252/len(wealth))-1\n    sharpe = cagr/vol if vol>0 else np.nan\n    dd = wealth/np.maximum.accumulate(wealth) - 1\n    mdd = dd.min()\n    avgdd = dd[dd<0].mean()\n    return dict(CAGR=cagr, Vol=vol, Sharpe=sharpe, MDD=mdd, AvgDD=avgdd)\n\n# Example: rho = 0.3, mu = 0\nrets = simulate_ar1_paths(n_paths=1, rho=0.3, mu_ann=0.0)\nrets = rets[:,0]\nwealth_bh = np.cumprod(1+rets)\nwealth_stop = apply_trailing_stop(rets)\n\n# Metrics\nprint(\"Buy & Hold:\", metrics(wealth_bh))\nprint(\"Stop-Loss:\", metrics(wealth_stop))\n\n# Plot\nplt.figure(figsize=(8,4))\nplt.plot(wealth_bh, label=\"Buy & Hold\")\nplt.plot(wealth_stop, label=\"5% Trailing Stop\")\nplt.title(\"Example Path — AR(1) ρ=0.3, μ=0\")\nplt.legend()\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBuy & Hold: {'CAGR': np.float64(0.04237321398912175), 'Vol': np.float64(0.05150267861021977), 'Sharpe': np.float64(0.8227380620299146), 'MDD': np.float64(-0.13412749497028176), 'AvgDD': np.float64(-0.049024746445191156)}\nStop-Loss: {'CAGR': np.float64(0.022248918103237925), 'Vol': np.float64(0.03398916770371736), 'Sharpe': np.float64(0.6545884941102745), 'MDD': np.float64(-0.06604965292696174), 'AvgDD': np.float64(-0.03989770367663479)}\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![AR(1) simulation — Buy & Hold vs 5% trailing stop-loss](03_simulation_framework_files/figure-html/simulate-ar1-output-2.png){#simulate-ar1 width=758 height=374}\n:::\n:::\n\n\n## Design choices\n\nFixed stop threshold: Here set at 5% to illustrate; later sweeps will show sensitivity.\n\nNo transaction costs: This isolates pure statistical effects; costs will be added in empirical sections.\n\nIn-sample vs out-of-sample: Since AR(1) parameters are known here, there’s no estimation error. This will not hold in real data.\n\nIn the next section, we will sweep $\\rho$ from -0.5 to 0.5 and drifts from -10% to +10% annually, holding volatility constant, to see when stops help/hurt on each performance dimension.\n\n",
    "supporting": [
      "03_simulation_framework_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}