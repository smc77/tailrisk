
# Simulation Framework
# Simulation Framework

We simulate synthetic return paths to test drawdown-mitigation rules under controlled statistical environments. This enables us to:

- Hold volatility constant while varying drift or autocorrelation.
- Quantify how stop-loss rules perform relative to buy-and-hold when return persistence changes.
- Observe how MDD, average drawdown, volatility, and Sharpe ratio respond to rule changes.

## AR(1) process with trailing stop-loss

The base process for log-returns is:

\[
r_t = \mu + \rho (r_{t-1} - \mu) + \sigma \varepsilon_t, \quad \varepsilon_t \sim \mathcal{N}(0,1)
\]

- $\mu$: daily drift  
- $\rho$: lag-1 autocorrelation coefficient  
- $\sigma$: daily volatility  
- We parameterize $\mu$ and $\sigma$ in **annualized** terms for interpretability.

The stop-loss rule is:

- **Trigger**: 5% trailing peak-to-trough decline in portfolio value.
- **Exit**: Go to cash immediately upon breach.
- **Re-entry**: Only when price exceeds the prior peak (“stop-out peak”), ensuring no premature re-risking.

---

## Implementation

```{python}
#| label: simulate-ar1
#| fig-cap: "AR(1) simulation — Buy & Hold vs 5% trailing stop-loss"
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

def simulate_ar1_paths(n_paths=100, n_days=252*5, mu_ann=0.0, sigma_ann=0.05, rho=0.0, seed=42):
    np.random.seed(seed)
    mu = mu_ann / 252
    sigma = sigma_ann / np.sqrt(252)
    rets = np.zeros((n_days, n_paths))
    shocks = np.random.randn(n_days, n_paths)
    for t in range(1, n_days):
        rets[t] = mu + rho * (rets[t-1] - mu) + sigma * shocks[t]
    return rets

def apply_trailing_stop(returns, stop=0.05):
    """returns: 1D array of daily returns"""
    wealth = np.cumprod(1 + returns)
    peak = np.maximum.accumulate(wealth)
    in_market = np.ones(len(wealth), dtype=bool)
    cash = 0.0
    stop_peak = peak[0]
    for t in range(1, len(wealth)):
        if in_market[t-1]:
            # Check stop breach
            if (wealth[t] / peak[t] - 1) <= -stop:
                in_market[t] = False
                cash = wealth[t]
                stop_peak = peak[t]
            else:
                in_market[t] = True
        else:
            # Stay in cash until break above stop_peak
            if wealth[t] >= stop_peak:
                in_market[t] = True
                cash = 0.0
            else:
                in_market[t] = False
    strat_wealth = np.ones(len(wealth))
    strat_wealth[0] = 1.0
    in_cash = False
    for t in range(1, len(wealth)):
        if in_market[t]:
            strat_wealth[t] = strat_wealth[t-1] * (1 + returns[t])
        else:
            strat_wealth[t] = strat_wealth[t-1]
    return strat_wealth

def metrics(wealth):
    rets = pd.Series(wealth).pct_change().dropna()
    vol = rets.std() * np.sqrt(252)
    cagr = (wealth[-1]/wealth[0])**(252/len(wealth))-1
    sharpe = cagr/vol if vol>0 else np.nan
    dd = wealth/np.maximum.accumulate(wealth) - 1
    mdd = dd.min()
    avgdd = dd[dd<0].mean()
    return dict(CAGR=cagr, Vol=vol, Sharpe=sharpe, MDD=mdd, AvgDD=avgdd)

# Example: rho = 0.3, mu = 0
rets = simulate_ar1_paths(n_paths=1, rho=0.3, mu_ann=0.0)
rets = rets[:,0]
wealth_bh = np.cumprod(1+rets)
wealth_stop = apply_trailing_stop(rets)

# Metrics
print("Buy & Hold:", metrics(wealth_bh))
print("Stop-Loss:", metrics(wealth_stop))

# Plot
plt.figure(figsize=(8,4))
plt.plot(wealth_bh, label="Buy & Hold")
plt.plot(wealth_stop, label="5% Trailing Stop")
plt.title("Example Path — AR(1) ρ=0.3, μ=0")
plt.legend()
plt.tight_layout()
plt.show()
```

## Design choices

Fixed stop threshold: Here set at 5% to illustrate; later sweeps will show sensitivity.

No transaction costs: This isolates pure statistical effects; costs will be added in empirical sections.

In-sample vs out-of-sample: Since AR(1) parameters are known here, there’s no estimation error. This will not hold in real data.

In the next section, we will sweep $\rho$ from -0.5 to 0.5 and drifts from -10% to +10% annually, holding volatility constant, to see when stops help/hurt on each performance dimension.
